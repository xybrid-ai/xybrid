/*
 * xybrid-ffi - C bindings for the xybrid ML inference SDK
 *
 * This header is auto-generated by cbindgen. Do not modify directly.
 *
 * Usage:
 *   #include "xybrid.h"
 *
 *   int main() {
 *       if (xybrid_init() != 0) {
 *           fprintf(stderr, "Failed to initialize: %s\n", xybrid_last_error());
 *           return 1;
 *       }
 *
 *       printf("xybrid version: %s\n", xybrid_version());
 *
 *       XybridModelLoaderHandle* loader = xybrid_model_loader_from_registry("kokoro-82m");
 *       XybridModelHandle* model = xybrid_model_loader_load(loader);
 *       XybridEnvelopeHandle* envelope = xybrid_envelope_text("Hello world");
 *       XybridResultHandle* result = xybrid_model_run(model, envelope);
 *
 *       if (xybrid_result_success(result)) {
 *           printf("Text: %s\n", xybrid_result_text(result));
 *       }
 *
 *       xybrid_result_free(result);
 *       xybrid_envelope_free(envelope);
 *       xybrid_model_free(model);
 *       xybrid_model_loader_free(loader);
 *
 *       return 0;
 *   }
 */


#ifndef XYBRID_H
#define XYBRID_H

/* Generated with cbindgen:0.26.0 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

/*
 Message role constants for conversation context.

 Use these values with `xybrid_envelope_text_with_role`:
 - `XYBRID_ROLE_SYSTEM` (0): System prompt
 - `XYBRID_ROLE_USER` (1): User message
 - `XYBRID_ROLE_ASSISTANT` (2): Assistant response
 */
#define XYBRID_ROLE_SYSTEM 0

#define XYBRID_ROLE_USER 1

#define XYBRID_ROLE_ASSISTANT 2

/*
 Opaque handle to a model loader.

 This handle is created by `xybrid_model_loader_from_registry` or
 `xybrid_model_loader_from_bundle` and must be freed with
 `xybrid_model_loader_free`.
 */
typedef struct XybridModelLoaderHandle {
  void *_0;
} XybridModelLoaderHandle;

/*
 Opaque handle to a loaded model.

 This handle is created by `xybrid_model_loader_load` and must be
 freed with `xybrid_model_free`.
 */
typedef struct XybridModelHandle {
  void *_0;
} XybridModelHandle;

/*
 Opaque handle to an envelope (input data).

 This handle is created by `xybrid_envelope_audio` or `xybrid_envelope_text`
 and must be freed with `xybrid_envelope_free`.
 */
typedef struct XybridEnvelopeHandle {
  void *_0;
} XybridEnvelopeHandle;

/*
 Opaque handle to a conversation context.

 This handle is created by `xybrid_context_new` and must be freed with
 `xybrid_context_free`.
 */
typedef struct XybridContextHandle {
  void *_0;
} XybridContextHandle;

/*
 Opaque handle to an inference result.

 This handle is created by `xybrid_model_run` and must be freed with
 `xybrid_result_free`.
 */
typedef struct XybridResultHandle {
  void *_0;
} XybridResultHandle;

/*
 Callback function type for streaming inference.

 This callback is invoked for each token generated during streaming inference.
 All string parameters are null-terminated UTF-8 and valid only for the duration
 of the callback invocation. The caller must copy any data they want to retain.

 # Parameters

 - `token`: The generated token text
 - `token_id`: The raw token ID (-1 if not available)
 - `index`: Zero-based index of this token in the generation sequence
 - `cumulative_text`: All generated text so far (concatenation of all tokens)
 - `finish_reason`: Reason for stopping, or null if generation is still in progress
 - `user_data`: The opaque pointer passed to `xybrid_model_run_streaming`
 */
typedef void (*XybridStreamCallback)(const char *token,
                                     int64_t token_id,
                                     uint32_t index,
                                     const char *cumulative_text,
                                     const char *finish_reason,
                                     void *user_data);

/*
 Initialize the xybrid library.

 This function should be called once before using any other xybrid functions.
 Currently this is a no-op but may perform initialization in the future.

 # Returns

 - `0` on success
 - Non-zero on failure (check `xybrid_last_error()` for details)

 # Example (C)

 ```c
 if (xybrid_init() != 0) {
     const char* error = xybrid_last_error();
     fprintf(stderr, "Failed to initialize: %s\n", error);
     return 1;
 }
 ```
 */
int32_t xybrid_init(void);

/*
 Get the library version string.

 Returns a pointer to a null-terminated string containing the library version.
 The returned pointer is valid for the lifetime of the library and should NOT
 be freed by the caller.

 # Returns

 A pointer to a static null-terminated version string, or null on error.

 # Example (C)

 ```c
 const char* version = xybrid_version();
 printf("xybrid version: %s\n", version);
 ```
 */
const char *xybrid_version(void);

/*
 Get the last error message.

 Returns a pointer to a null-terminated string containing the last error
 message, or null if no error has occurred. The returned pointer is valid
 until the next xybrid function call on the same thread.

 # Returns

 A pointer to the last error message, or null if no error.

 # Example (C)

 ```c
 XybridModelHandle* model = xybrid_model_loader_load(loader);
 if (model == NULL) {
     const char* error = xybrid_last_error();
     fprintf(stderr, "Failed to load: %s\n", error ? error : "unknown error");
 }
 ```
 */
const char *xybrid_last_error(void);

/*
 Free a string allocated by the library.

 This function should be called to free strings returned by xybrid functions
 that specify the caller must free the result. Do NOT use this to free
 strings returned by `xybrid_version()` or `xybrid_last_error()`.

 # Safety

 The pointer must be a valid pointer to a string allocated by xybrid,
 or null. Passing an invalid pointer causes undefined behavior.

 # Example (C)

 ```c
 char* model_id = xybrid_model_id(model);
 printf("Model: %s\n", model_id);
 xybrid_free_string(model_id);
 ```
 */
void xybrid_free_string(char *s);

/*
 Create a model loader from a registry model ID.

 This creates a loader that will fetch the model from the xybrid registry
 when `xybrid_model_loader_load` is called.

 # Parameters

 - `model_id`: A null-terminated string containing the model ID (e.g., "kokoro-82m").

 # Returns

 A handle to the model loader, or null on failure.
 On failure, call `xybrid_last_error()` to get the error message.

 # Example (C)

 ```c
 XybridModelLoaderHandle* loader = xybrid_model_loader_from_registry("kokoro-82m");
 if (loader == NULL) {
     fprintf(stderr, "Failed: %s\n", xybrid_last_error());
     return 1;
 }
 // Use loader...
 xybrid_model_loader_free(loader);
 ```
 */
struct XybridModelLoaderHandle *xybrid_model_loader_from_registry(const char *model_id);

/*
 Create a model loader from a local bundle path.

 This creates a loader that will load the model from the specified local path
 when `xybrid_model_loader_load` is called.

 # Parameters

 - `path`: A null-terminated string containing the path to the model bundle.

 # Returns

 A handle to the model loader, or null on failure.
 On failure, call `xybrid_last_error()` to get the error message.

 # Example (C)

 ```c
 XybridModelLoaderHandle* loader = xybrid_model_loader_from_bundle("/path/to/model");
 if (loader == NULL) {
     fprintf(stderr, "Failed: %s\n", xybrid_last_error());
     return 1;
 }
 // Use loader...
 xybrid_model_loader_free(loader);
 ```
 */
struct XybridModelLoaderHandle *xybrid_model_loader_from_bundle(const char *path);

/*
 Load a model using the loader.

 This function loads the model from the registry or local bundle,
 depending on how the loader was created.

 # Parameters

 - `handle`: A handle to the model loader created by `xybrid_model_loader_from_registry`
   or `xybrid_model_loader_from_bundle`.

 # Returns

 A handle to the loaded model, or null on failure.
 On failure, call `xybrid_last_error()` to get the error message.

 # Example (C)

 ```c
 XybridModelHandle* model = xybrid_model_loader_load(loader);
 if (model == NULL) {
     fprintf(stderr, "Failed: %s\n", xybrid_last_error());
     xybrid_model_loader_free(loader);
     return 1;
 }
 // Use model...
 xybrid_model_free(model);
 xybrid_model_loader_free(loader);
 ```
 */
struct XybridModelHandle *xybrid_model_loader_load(struct XybridModelLoaderHandle *handle);

/*
 Free a model loader handle.

 This function frees the memory associated with a model loader handle.
 After calling this function, the handle is no longer valid.

 # Parameters

 - `handle`: A handle to the model loader to free. May be null (no-op).

 # Example (C)

 ```c
 xybrid_model_loader_free(loader);
 loader = NULL; // Good practice: null out after freeing
 ```
 */
void xybrid_model_loader_free(struct XybridModelLoaderHandle *handle);

/*
 Create an envelope containing audio data.

 This function creates an envelope containing raw audio bytes with the
 specified sample rate and channel count.

 # Parameters

 - `bytes`: Pointer to the raw audio bytes. May be null if `len` is 0.
 - `len`: Length of the audio bytes array.
 - `sample_rate`: Sample rate in Hz (e.g., 16000 for 16kHz).
 - `channels`: Number of audio channels (e.g., 1 for mono, 2 for stereo).

 # Returns

 A handle to the envelope, or null on failure.
 On failure, call `xybrid_last_error()` to get the error message.

 # Example (C)

 ```c
 uint8_t audio_data[] = { /* PCM audio bytes */ };
 XybridEnvelopeHandle* envelope = xybrid_envelope_audio(
     audio_data, sizeof(audio_data), 16000, 1);
 if (envelope == NULL) {
     fprintf(stderr, "Failed: %s\n", xybrid_last_error());
     return 1;
 }
 // Use envelope...
 xybrid_envelope_free(envelope);
 ```
 */
struct XybridEnvelopeHandle *xybrid_envelope_audio(const uint8_t *bytes,
                                                   uintptr_t len,
                                                   uint32_t sample_rate,
                                                   uint32_t channels);

/*
 Create an envelope containing text data.

 This function creates an envelope containing text for TTS or LLM inference.

 # Parameters

 - `text`: A null-terminated string containing the text. Must not be null.

 # Returns

 A handle to the envelope, or null on failure.
 On failure, call `xybrid_last_error()` to get the error message.

 # Example (C)

 ```c
 XybridEnvelopeHandle* envelope = xybrid_envelope_text("Hello, world!");
 if (envelope == NULL) {
     fprintf(stderr, "Failed: %s\n", xybrid_last_error());
     return 1;
 }
 // Use envelope...
 xybrid_envelope_free(envelope);
 ```
 */
struct XybridEnvelopeHandle *xybrid_envelope_text(const char *text);

/*
 Free an envelope handle.

 This function frees the memory associated with an envelope handle.
 After calling this function, the handle is no longer valid.

 # Parameters

 - `handle`: A handle to the envelope to free. May be null (no-op).

 # Example (C)

 ```c
 xybrid_envelope_free(envelope);
 envelope = NULL; // Good practice: null out after freeing
 ```
 */
void xybrid_envelope_free(struct XybridEnvelopeHandle *handle);

/*
 Create a new conversation context with a generated UUID.

 # Returns

 A handle to the conversation context, or null on failure.

 # Example (C)

 ```c
 XybridContextHandle* ctx = xybrid_context_new();
 if (ctx == NULL) {
     fprintf(stderr, "Failed: %s\n", xybrid_last_error());
     return 1;
 }
 // Use context...
 xybrid_context_free(ctx);
 ```
 */
struct XybridContextHandle *xybrid_context_new(void);

/*
 Create a new conversation context with a specific ID.

 # Parameters

 - `id`: A null-terminated string containing the context ID.

 # Returns

 A handle to the conversation context, or null on failure.

 # Example (C)

 ```c
 XybridContextHandle* ctx = xybrid_context_with_id("session-123");
 ```
 */
struct XybridContextHandle *xybrid_context_with_id(const char *id);

/*
 Set the system prompt for a conversation context.

 The system prompt defines the assistant's behavior and persists
 across `xybrid_context_clear()` calls.

 # Parameters

 - `handle`: A handle to the conversation context.
 - `text`: A null-terminated string containing the system prompt.

 # Returns

 - `0` on success
 - Non-zero on failure (check `xybrid_last_error()`)

 # Example (C)

 ```c
 xybrid_context_set_system(ctx, "You are a helpful assistant.");
 ```
 */
int32_t xybrid_context_set_system(struct XybridContextHandle *handle, const char *text);

/*
 Set the maximum history length for a conversation context.

 When the history exceeds this limit, oldest messages are dropped (FIFO).
 Default is 50 messages.

 # Parameters

 - `handle`: A handle to the conversation context.
 - `max_len`: Maximum number of history entries.

 # Returns

 - `0` on success
 - Non-zero on failure
 */
int32_t xybrid_context_set_max_history_len(struct XybridContextHandle *handle, uint32_t max_len);

/*
 Push an envelope to the conversation history.

 The envelope should have a role set (use `xybrid_envelope_text_with_role`).

 # Parameters

 - `handle`: A handle to the conversation context.
 - `envelope`: A handle to the envelope to push.

 # Returns

 - `0` on success
 - Non-zero on failure

 # Example (C)

 ```c
 XybridEnvelopeHandle* msg = xybrid_envelope_text_with_role("Hello!", XYBRID_ROLE_USER);
 xybrid_context_push(ctx, msg);
 xybrid_envelope_free(msg);
 ```
 */
int32_t xybrid_context_push(struct XybridContextHandle *handle,
                            struct XybridEnvelopeHandle *envelope);

/*
 Clear the conversation history but preserve the system prompt and ID.

 # Parameters

 - `handle`: A handle to the conversation context.

 # Returns

 - `0` on success
 - Non-zero on failure
 */
int32_t xybrid_context_clear(struct XybridContextHandle *handle);

/*
 Get the conversation context ID.

 Returns a pointer to a null-terminated string containing the context ID.
 The returned pointer is valid until the context handle is freed.
 Do NOT free the returned string.

 # Parameters

 - `handle`: A handle to the conversation context.

 # Returns

 A pointer to the context ID string, or null on failure.
 */
const char *xybrid_context_id(struct XybridContextHandle *handle);

/*
 Get the current history length (excluding system prompt).

 # Parameters

 - `handle`: A handle to the conversation context.

 # Returns

 The number of messages in the history, or 0 if the handle is null/invalid.
 */
uint32_t xybrid_context_history_len(struct XybridContextHandle *handle);

/*
 Check if a system prompt is set.

 # Parameters

 - `handle`: A handle to the conversation context.

 # Returns

 - `1` if a system prompt is set
 - `0` if not, or if the handle is null/invalid
 */
int32_t xybrid_context_has_system(struct XybridContextHandle *handle);

/*
 Free a conversation context handle.

 This function frees the memory associated with a context handle.
 After calling this function, the handle is no longer valid.

 # Parameters

 - `handle`: A handle to the context to free. May be null (no-op).
 */
void xybrid_context_free(struct XybridContextHandle *handle);

/*
 Create an envelope containing text data with a message role.

 This is used for building conversation context with proper role tagging.

 # Parameters

 - `text`: A null-terminated string containing the text.
 - `role`: The message role (0=System, 1=User, 2=Assistant).

 # Returns

 A handle to the envelope, or null on failure.

 # Example (C)

 ```c
 XybridEnvelopeHandle* user_msg = xybrid_envelope_text_with_role("Hello!", XYBRID_ROLE_USER);
 xybrid_context_push(ctx, user_msg);
 xybrid_envelope_free(user_msg);
 ```
 */
struct XybridEnvelopeHandle *xybrid_envelope_text_with_role(const char *text, int32_t role);

/*
 Run inference on a model with the given input envelope.

 This function executes inference using the loaded model and returns
 a result handle containing the output or error information.

 # Parameters

 - `model`: A handle to the loaded model (from `xybrid_model_loader_load`).
 - `envelope`: A handle to the input envelope (from `xybrid_envelope_audio` or `xybrid_envelope_text`).

 # Returns

 A handle to the result, or null on failure.
 On failure, call `xybrid_last_error()` to get the error message.
 The envelope is NOT consumed - it can be reused for multiple inferences.

 # Example (C)

 ```c
 XybridResultHandle* result = xybrid_model_run(model, envelope);
 if (result == NULL) {
     fprintf(stderr, "Inference failed: %s\n", xybrid_last_error());
     return 1;
 }

 if (xybrid_result_success(result)) {
     const char* text = xybrid_result_text(result);
     printf("Result: %s\n", text);
 } else {
     const char* error = xybrid_result_error(result);
     printf("Error: %s\n", error);
 }

 xybrid_result_free(result);
 ```
 */
struct XybridResultHandle *xybrid_model_run(struct XybridModelHandle *model,
                                            struct XybridEnvelopeHandle *envelope);

/*
 Run inference on a model with conversation context.

 This function executes inference using the loaded model with conversation
 history. The context provides previous messages which are formatted into
 the prompt using the model's chat template.

 # Parameters

 - `model`: A handle to the loaded model.
 - `envelope`: A handle to the input envelope (current user message).
 - `context`: A handle to the conversation context.

 # Returns

 A handle to the result, or null on failure.
 The envelope and context are NOT consumed - they can be reused.

 # Example (C)

 ```c
 XybridContextHandle* ctx = xybrid_context_new();
 xybrid_context_set_system(ctx, "You are a helpful assistant.");

 XybridEnvelopeHandle* user_msg = xybrid_envelope_text_with_role("Hello!", XYBRID_ROLE_USER);
 xybrid_context_push(ctx, user_msg);

 XybridResultHandle* result = xybrid_model_run_with_context(model, user_msg, ctx);
 if (xybrid_result_success(result)) {
     const char* response = xybrid_result_text(result);
     printf("Assistant: %s\n", response);

     // Add assistant response to context
     XybridEnvelopeHandle* asst_msg = xybrid_envelope_text_with_role(response, XYBRID_ROLE_ASSISTANT);
     xybrid_context_push(ctx, asst_msg);
     xybrid_envelope_free(asst_msg);
 }

 xybrid_result_free(result);
 xybrid_envelope_free(user_msg);
 xybrid_context_free(ctx);
 ```
 */
struct XybridResultHandle *xybrid_model_run_with_context(struct XybridModelHandle *model,
                                                         struct XybridEnvelopeHandle *envelope,
                                                         struct XybridContextHandle *context);

/*
 Get the model ID of a loaded model.

 Returns a pointer to a null-terminated string containing the model ID.
 The caller is responsible for freeing the returned string using
 `xybrid_free_string()`.

 # Parameters

 - `model`: A handle to the loaded model.

 # Returns

 A pointer to a null-terminated string containing the model ID,
 or null on failure. The caller must free this string with `xybrid_free_string()`.

 # Example (C)

 ```c
 char* model_id = xybrid_model_id(model);
 if (model_id != NULL) {
     printf("Model ID: %s\n", model_id);
     xybrid_free_string(model_id);
 }
 ```
 */
char *xybrid_model_id(struct XybridModelHandle *model);

/*
 Check if a model supports token-by-token streaming.

 Returns 1 if the model supports true token-by-token streaming (LLM models
 with GGUF format when LLM features are enabled), 0 otherwise.

 Note: `xybrid_model_run_streaming()` works for all models, but only LLM
 models get true token-by-token streaming; others emit a single result.

 # Parameters

 - `model`: A handle to the loaded model.

 # Returns

 - `1` if the model supports token streaming
 - `0` if it does not, or if the handle is null/invalid

 # Example (C)

 ```c
 if (xybrid_model_supports_token_streaming(model)) {
     // Use streaming inference
 } else {
     // Use batch inference
 }
 ```
 */
int32_t xybrid_model_supports_token_streaming(struct XybridModelHandle *model);

/*
 Run streaming inference on a model with the given input envelope.

 This function blocks until inference is complete. For each token generated,
 the callback is invoked with the token data. After all tokens are emitted,
 the function returns a result handle with the final output.

 For non-LLM models, a single callback invocation occurs with the complete result.

 # Parameters

 - `model`: A handle to the loaded model.
 - `envelope`: A handle to the input envelope.
 - `callback`: Function pointer invoked for each generated token.
 - `user_data`: Opaque pointer passed through to every callback invocation.

 # Returns

 A handle to the final result, or null on failure.
 On failure, call `xybrid_last_error()` to get the error message.

 # Thread Safety

 The callback is invoked from the calling thread. The caller must ensure
 that `user_data` is valid for the duration of the call.

 # Example (C)

 ```c
 void on_token(const char* token, int64_t token_id, uint32_t index,
               const char* cumulative, const char* finish, void* ctx) {
     printf("%s", token);
     fflush(stdout);
 }

 XybridResultHandle* result = xybrid_model_run_streaming(
     model, envelope, on_token, NULL);
 ```
 */
struct XybridResultHandle *xybrid_model_run_streaming(struct XybridModelHandle *model,
                                                      struct XybridEnvelopeHandle *envelope,
                                                      XybridStreamCallback callback,
                                                      void *user_data);

/*
 Run streaming inference on a model with conversation context.

 Same as `xybrid_model_run_streaming` but includes conversation history
 for multi-turn LLM interactions.

 # Parameters

 - `model`: A handle to the loaded model.
 - `envelope`: A handle to the input envelope (current user message).
 - `context`: A handle to the conversation context.
 - `callback`: Function pointer invoked for each generated token.
 - `user_data`: Opaque pointer passed through to every callback invocation.

 # Returns

 A handle to the final result, or null on failure.
 The envelope and context are NOT consumed - they can be reused.

 # Example (C)

 ```c
 XybridContextHandle* ctx = xybrid_context_new();
 xybrid_context_set_system(ctx, "You are a helpful assistant.");

 XybridEnvelopeHandle* msg = xybrid_envelope_text_with_role("Hello!", XYBRID_ROLE_USER);
 xybrid_context_push(ctx, msg);

 XybridResultHandle* result = xybrid_model_run_streaming_with_context(
     model, msg, ctx, on_token, NULL);
 ```
 */
struct XybridResultHandle *xybrid_model_run_streaming_with_context(struct XybridModelHandle *model,
                                                                   struct XybridEnvelopeHandle *envelope,
                                                                   struct XybridContextHandle *context,
                                                                   XybridStreamCallback callback,
                                                                   void *user_data);

/*
 Free a model handle.

 This function frees the memory associated with a model handle.
 After calling this function, the handle is no longer valid.

 # Parameters

 - `handle`: A handle to the model to free. May be null (no-op).

 # Example (C)

 ```c
 xybrid_model_free(model);
 model = NULL; // Good practice: null out after freeing
 ```
 */
void xybrid_model_free(struct XybridModelHandle *handle);

/*
 Check if the inference was successful.

 Returns 1 if the inference succeeded, 0 if it failed.
 If the handle is null or invalid, returns 0.

 # Parameters

 - `result`: A handle to the inference result.

 # Returns

 - `1` if success is true
 - `0` if success is false, or if the handle is null/invalid

 # Example (C)

 ```c
 if (xybrid_result_success(result)) {
     const char* text = xybrid_result_text(result);
     printf("Result: %s\n", text);
 } else {
     const char* error = xybrid_result_error(result);
     printf("Error: %s\n", error ? error : "unknown");
 }
 ```
 */
int32_t xybrid_result_success(struct XybridResultHandle *result);

/*
 Get the error message from a failed inference.

 Returns a pointer to a null-terminated string containing the error message,
 or null if there was no error. The returned pointer is valid for the
 lifetime of the result handle - do NOT free it with xybrid_free_string().

 # Parameters

 - `result`: A handle to the inference result.

 # Returns

 A pointer to the error message string, or null if no error.
 The pointer is valid until the result handle is freed.

 # Example (C)

 ```c
 if (!xybrid_result_success(result)) {
     const char* error = xybrid_result_error(result);
     fprintf(stderr, "Inference failed: %s\n", error ? error : "unknown error");
 }
 ```
 */
const char *xybrid_result_error(struct XybridResultHandle *result);

/*
 Get the text output from an inference result.

 Returns a pointer to a null-terminated string containing the text output,
 or null if the result does not contain text. The returned pointer is valid
 for the lifetime of the result handle - do NOT free it with xybrid_free_string().

 # Parameters

 - `result`: A handle to the inference result.

 # Returns

 A pointer to the text output string, or null if no text output.
 The pointer is valid until the result handle is freed.

 # Example (C)

 ```c
 XybridResultHandle* result = xybrid_model_run(model, envelope);
 if (xybrid_result_success(result)) {
     const char* text = xybrid_result_text(result);
     if (text != NULL) {
         printf("Transcription: %s\n", text);
     }
 }
 xybrid_result_free(result);
 ```
 */
const char *xybrid_result_text(struct XybridResultHandle *result);

/*
 Get the latency in milliseconds from an inference result.

 Returns the inference latency in milliseconds.
 If the handle is null or invalid, returns 0.

 # Parameters

 - `result`: A handle to the inference result.

 # Returns

 The inference latency in milliseconds, or 0 if the handle is null/invalid.

 # Example (C)

 ```c
 uint32_t latency = xybrid_result_latency_ms(result);
 printf("Inference took %u ms\n", latency);
 ```
 */
uint32_t xybrid_result_latency_ms(struct XybridResultHandle *result);

/*
 Free an inference result handle.

 This function frees the memory associated with an inference result handle.
 After calling this function, the handle is no longer valid.

 # Parameters

 - `handle`: A handle to the result to free. May be null (no-op).

 # Example (C)

 ```c
 XybridResultHandle* result = xybrid_model_run(model, envelope);
 // ... use result ...
 xybrid_result_free(result);
 result = NULL; // Good practice: null out after freeing
 ```
 */
void xybrid_result_free(struct XybridResultHandle *handle);

#endif /* XYBRID_H */
