// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;


namespace Xybrid.Native
{
    internal static unsafe partial class NativeMethods
    {
        const string __DllName = "xybrid_ffi";



        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void xybrid_model_run_streaming_callback_delegate(byte* token, long token_id, uint index, byte* cumulative_text, byte* finish_reason, void* user_data);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void xybrid_model_run_streaming_with_context_callback_delegate(byte* token, long token_id, uint index, byte* cumulative_text, byte* finish_reason, void* user_data);



        /// <summary>
        ///  Initialize the xybrid library.
        ///
        ///  This function should be called once before using any other xybrid functions.
        ///  Currently this is a no-op but may perform initialization in the future.
        ///
        ///  # Returns
        ///
        ///  - `0` on success
        ///  - Non-zero on failure (check `xybrid_last_error()` for details)
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  if (xybrid_init() != 0) {
        ///      const char* error = xybrid_last_error();
        ///      fprintf(stderr, "Failed to initialize: %s\n", error);
        ///      return 1;
        ///  }
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_init", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int xybrid_init();

        /// <summary>
        ///  Get the library version string.
        ///
        ///  Returns a pointer to a null-terminated string containing the library version.
        ///  The returned pointer is valid for the lifetime of the library and should NOT
        ///  be freed by the caller.
        ///
        ///  # Returns
        ///
        ///  A pointer to a static null-terminated version string, or null on error.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  const char* version = xybrid_version();
        ///  printf("xybrid version: %s\n", version);
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_version", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* xybrid_version();

        /// <summary>
        ///  Get the last error message.
        ///
        ///  Returns a pointer to a null-terminated string containing the last error
        ///  message, or null if no error has occurred. The returned pointer is valid
        ///  until the next xybrid function call on the same thread.
        ///
        ///  # Returns
        ///
        ///  A pointer to the last error message, or null if no error.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  XybridModelHandle* model = xybrid_model_loader_load(loader);
        ///  if (model == NULL) {
        ///      const char* error = xybrid_last_error();
        ///      fprintf(stderr, "Failed to load: %s\n", error ? error : "unknown error");
        ///  }
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_last_error", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* xybrid_last_error();

        /// <summary>
        ///  Free a string allocated by the library.
        ///
        ///  This function should be called to free strings returned by xybrid functions
        ///  that specify the caller must free the result. Do NOT use this to free
        ///  strings returned by `xybrid_version()` or `xybrid_last_error()`.
        ///
        ///  # Safety
        ///
        ///  The pointer must be a valid pointer to a string allocated by xybrid,
        ///  or null. Passing an invalid pointer causes undefined behavior.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  char* model_id = xybrid_model_id(model);
        ///  printf("Model: %s\n", model_id);
        ///  xybrid_free_string(model_id);
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_free_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void xybrid_free_string(byte* s);

        /// <summary>
        ///  Create a model loader from a registry model ID.
        ///
        ///  This creates a loader that will fetch the model from the xybrid registry
        ///  when `xybrid_model_loader_load` is called.
        ///
        ///  # Parameters
        ///
        ///  - `model_id`: A null-terminated string containing the model ID (e.g., "kokoro-82m").
        ///
        ///  # Returns
        ///
        ///  A handle to the model loader, or null on failure.
        ///  On failure, call `xybrid_last_error()` to get the error message.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  XybridModelLoaderHandle* loader = xybrid_model_loader_from_registry("kokoro-82m");
        ///  if (loader == NULL) {
        ///      fprintf(stderr, "Failed: %s\n", xybrid_last_error());
        ///      return 1;
        ///  }
        ///  // Use loader...
        ///  xybrid_model_loader_free(loader);
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_model_loader_from_registry", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern XybridModelLoaderHandle* xybrid_model_loader_from_registry(byte* model_id);

        /// <summary>
        ///  Create a model loader from a local bundle path.
        ///
        ///  This creates a loader that will load the model from the specified local path
        ///  when `xybrid_model_loader_load` is called.
        ///
        ///  # Parameters
        ///
        ///  - `path`: A null-terminated string containing the path to the model bundle.
        ///
        ///  # Returns
        ///
        ///  A handle to the model loader, or null on failure.
        ///  On failure, call `xybrid_last_error()` to get the error message.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  XybridModelLoaderHandle* loader = xybrid_model_loader_from_bundle("/path/to/model");
        ///  if (loader == NULL) {
        ///      fprintf(stderr, "Failed: %s\n", xybrid_last_error());
        ///      return 1;
        ///  }
        ///  // Use loader...
        ///  xybrid_model_loader_free(loader);
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_model_loader_from_bundle", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern XybridModelLoaderHandle* xybrid_model_loader_from_bundle(byte* path);

        /// <summary>
        ///  Load a model using the loader.
        ///
        ///  This function loads the model from the registry or local bundle,
        ///  depending on how the loader was created.
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to the model loader created by `xybrid_model_loader_from_registry`
        ///    or `xybrid_model_loader_from_bundle`.
        ///
        ///  # Returns
        ///
        ///  A handle to the loaded model, or null on failure.
        ///  On failure, call `xybrid_last_error()` to get the error message.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  XybridModelHandle* model = xybrid_model_loader_load(loader);
        ///  if (model == NULL) {
        ///      fprintf(stderr, "Failed: %s\n", xybrid_last_error());
        ///      xybrid_model_loader_free(loader);
        ///      return 1;
        ///  }
        ///  // Use model...
        ///  xybrid_model_free(model);
        ///  xybrid_model_loader_free(loader);
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_model_loader_load", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern XybridModelHandle* xybrid_model_loader_load(XybridModelLoaderHandle* handle);

        /// <summary>
        ///  Free a model loader handle.
        ///
        ///  This function frees the memory associated with a model loader handle.
        ///  After calling this function, the handle is no longer valid.
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to the model loader to free. May be null (no-op).
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  xybrid_model_loader_free(loader);
        ///  loader = NULL; // Good practice: null out after freeing
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_model_loader_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void xybrid_model_loader_free(XybridModelLoaderHandle* handle);

        /// <summary>
        ///  Create an envelope containing audio data.
        ///
        ///  This function creates an envelope containing raw audio bytes with the
        ///  specified sample rate and channel count.
        ///
        ///  # Parameters
        ///
        ///  - `bytes`: Pointer to the raw audio bytes. May be null if `len` is 0.
        ///  - `len`: Length of the audio bytes array.
        ///  - `sample_rate`: Sample rate in Hz (e.g., 16000 for 16kHz).
        ///  - `channels`: Number of audio channels (e.g., 1 for mono, 2 for stereo).
        ///
        ///  # Returns
        ///
        ///  A handle to the envelope, or null on failure.
        ///  On failure, call `xybrid_last_error()` to get the error message.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  uint8_t audio_data[] = { /* PCM audio bytes */ };
        ///  XybridEnvelopeHandle* envelope = xybrid_envelope_audio(
        ///      audio_data, sizeof(audio_data), 16000, 1);
        ///  if (envelope == NULL) {
        ///      fprintf(stderr, "Failed: %s\n", xybrid_last_error());
        ///      return 1;
        ///  }
        ///  // Use envelope...
        ///  xybrid_envelope_free(envelope);
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_envelope_audio", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern XybridEnvelopeHandle* xybrid_envelope_audio(byte* bytes, nuint len, uint sample_rate, uint channels);

        /// <summary>
        ///  Create an envelope containing text data.
        ///
        ///  This function creates an envelope containing text for TTS or LLM inference.
        ///
        ///  # Parameters
        ///
        ///  - `text`: A null-terminated string containing the text. Must not be null.
        ///
        ///  # Returns
        ///
        ///  A handle to the envelope, or null on failure.
        ///  On failure, call `xybrid_last_error()` to get the error message.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  XybridEnvelopeHandle* envelope = xybrid_envelope_text("Hello, world!");
        ///  if (envelope == NULL) {
        ///      fprintf(stderr, "Failed: %s\n", xybrid_last_error());
        ///      return 1;
        ///  }
        ///  // Use envelope...
        ///  xybrid_envelope_free(envelope);
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_envelope_text", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern XybridEnvelopeHandle* xybrid_envelope_text(byte* text);

        /// <summary>
        ///  Free an envelope handle.
        ///
        ///  This function frees the memory associated with an envelope handle.
        ///  After calling this function, the handle is no longer valid.
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to the envelope to free. May be null (no-op).
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  xybrid_envelope_free(envelope);
        ///  envelope = NULL; // Good practice: null out after freeing
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_envelope_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void xybrid_envelope_free(XybridEnvelopeHandle* handle);

        /// <summary>
        ///  Create a new conversation context with a generated UUID.
        ///
        ///  # Returns
        ///
        ///  A handle to the conversation context, or null on failure.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  XybridContextHandle* ctx = xybrid_context_new();
        ///  if (ctx == NULL) {
        ///      fprintf(stderr, "Failed: %s\n", xybrid_last_error());
        ///      return 1;
        ///  }
        ///  // Use context...
        ///  xybrid_context_free(ctx);
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_context_new", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern XybridContextHandle* xybrid_context_new();

        /// <summary>
        ///  Create a new conversation context with a specific ID.
        ///
        ///  # Parameters
        ///
        ///  - `id`: A null-terminated string containing the context ID.
        ///
        ///  # Returns
        ///
        ///  A handle to the conversation context, or null on failure.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  XybridContextHandle* ctx = xybrid_context_with_id("session-123");
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_context_with_id", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern XybridContextHandle* xybrid_context_with_id(byte* id);

        /// <summary>
        ///  Set the system prompt for a conversation context.
        ///
        ///  The system prompt defines the assistant's behavior and persists
        ///  across `xybrid_context_clear()` calls.
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to the conversation context.
        ///  - `text`: A null-terminated string containing the system prompt.
        ///
        ///  # Returns
        ///
        ///  - `0` on success
        ///  - Non-zero on failure (check `xybrid_last_error()`)
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  xybrid_context_set_system(ctx, "You are a helpful assistant.");
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_context_set_system", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int xybrid_context_set_system(XybridContextHandle* handle, byte* text);

        /// <summary>
        ///  Set the maximum history length for a conversation context.
        ///
        ///  When the history exceeds this limit, oldest messages are dropped (FIFO).
        ///  Default is 50 messages.
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to the conversation context.
        ///  - `max_len`: Maximum number of history entries.
        ///
        ///  # Returns
        ///
        ///  - `0` on success
        ///  - Non-zero on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_context_set_max_history_len", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int xybrid_context_set_max_history_len(XybridContextHandle* handle, uint max_len);

        /// <summary>
        ///  Push an envelope to the conversation history.
        ///
        ///  The envelope should have a role set (use `xybrid_envelope_text_with_role`).
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to the conversation context.
        ///  - `envelope`: A handle to the envelope to push.
        ///
        ///  # Returns
        ///
        ///  - `0` on success
        ///  - Non-zero on failure
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  XybridEnvelopeHandle* msg = xybrid_envelope_text_with_role("Hello!", XYBRID_ROLE_USER);
        ///  xybrid_context_push(ctx, msg);
        ///  xybrid_envelope_free(msg);
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_context_push", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int xybrid_context_push(XybridContextHandle* handle, XybridEnvelopeHandle* envelope);

        /// <summary>
        ///  Clear the conversation history but preserve the system prompt and ID.
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to the conversation context.
        ///
        ///  # Returns
        ///
        ///  - `0` on success
        ///  - Non-zero on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_context_clear", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int xybrid_context_clear(XybridContextHandle* handle);

        /// <summary>
        ///  Get the conversation context ID.
        ///
        ///  Returns a pointer to a null-terminated string containing the context ID.
        ///  The returned pointer is valid until the context handle is freed.
        ///  Do NOT free the returned string.
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to the conversation context.
        ///
        ///  # Returns
        ///
        ///  A pointer to the context ID string, or null on failure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_context_id", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* xybrid_context_id(XybridContextHandle* handle);

        /// <summary>
        ///  Get the current history length (excluding system prompt).
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to the conversation context.
        ///
        ///  # Returns
        ///
        ///  The number of messages in the history, or 0 if the handle is null/invalid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_context_history_len", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern uint xybrid_context_history_len(XybridContextHandle* handle);

        /// <summary>
        ///  Check if a system prompt is set.
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to the conversation context.
        ///
        ///  # Returns
        ///
        ///  - `1` if a system prompt is set
        ///  - `0` if not, or if the handle is null/invalid
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_context_has_system", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int xybrid_context_has_system(XybridContextHandle* handle);

        /// <summary>
        ///  Free a conversation context handle.
        ///
        ///  This function frees the memory associated with a context handle.
        ///  After calling this function, the handle is no longer valid.
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to the context to free. May be null (no-op).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_context_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void xybrid_context_free(XybridContextHandle* handle);

        /// <summary>
        ///  Create an envelope containing text data with a message role.
        ///
        ///  This is used for building conversation context with proper role tagging.
        ///
        ///  # Parameters
        ///
        ///  - `text`: A null-terminated string containing the text.
        ///  - `role`: The message role (0=System, 1=User, 2=Assistant).
        ///
        ///  # Returns
        ///
        ///  A handle to the envelope, or null on failure.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  XybridEnvelopeHandle* user_msg = xybrid_envelope_text_with_role("Hello!", XYBRID_ROLE_USER);
        ///  xybrid_context_push(ctx, user_msg);
        ///  xybrid_envelope_free(user_msg);
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_envelope_text_with_role", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern XybridEnvelopeHandle* xybrid_envelope_text_with_role(byte* text, int role);

        /// <summary>
        ///  Run inference on a model with the given input envelope.
        ///
        ///  This function executes inference using the loaded model and returns
        ///  a result handle containing the output or error information.
        ///
        ///  # Parameters
        ///
        ///  - `model`: A handle to the loaded model (from `xybrid_model_loader_load`).
        ///  - `envelope`: A handle to the input envelope (from `xybrid_envelope_audio` or `xybrid_envelope_text`).
        ///
        ///  # Returns
        ///
        ///  A handle to the result, or null on failure.
        ///  On failure, call `xybrid_last_error()` to get the error message.
        ///  The envelope is NOT consumed - it can be reused for multiple inferences.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  XybridResultHandle* result = xybrid_model_run(model, envelope);
        ///  if (result == NULL) {
        ///      fprintf(stderr, "Inference failed: %s\n", xybrid_last_error());
        ///      return 1;
        ///  }
        ///
        ///  if (xybrid_result_success(result)) {
        ///      const char* text = xybrid_result_text(result);
        ///      printf("Result: %s\n", text);
        ///  } else {
        ///      const char* error = xybrid_result_error(result);
        ///      printf("Error: %s\n", error);
        ///  }
        ///
        ///  xybrid_result_free(result);
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_model_run", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern XybridResultHandle* xybrid_model_run(XybridModelHandle* model, XybridEnvelopeHandle* envelope);

        /// <summary>
        ///  Run inference on a model with conversation context.
        ///
        ///  This function executes inference using the loaded model with conversation
        ///  history. The context provides previous messages which are formatted into
        ///  the prompt using the model's chat template.
        ///
        ///  # Parameters
        ///
        ///  - `model`: A handle to the loaded model.
        ///  - `envelope`: A handle to the input envelope (current user message).
        ///  - `context`: A handle to the conversation context.
        ///
        ///  # Returns
        ///
        ///  A handle to the result, or null on failure.
        ///  The envelope and context are NOT consumed - they can be reused.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  XybridContextHandle* ctx = xybrid_context_new();
        ///  xybrid_context_set_system(ctx, "You are a helpful assistant.");
        ///
        ///  XybridEnvelopeHandle* user_msg = xybrid_envelope_text_with_role("Hello!", XYBRID_ROLE_USER);
        ///  xybrid_context_push(ctx, user_msg);
        ///
        ///  XybridResultHandle* result = xybrid_model_run_with_context(model, user_msg, ctx);
        ///  if (xybrid_result_success(result)) {
        ///      const char* response = xybrid_result_text(result);
        ///      printf("Assistant: %s\n", response);
        ///
        ///      // Add assistant response to context
        ///      XybridEnvelopeHandle* asst_msg = xybrid_envelope_text_with_role(response, XYBRID_ROLE_ASSISTANT);
        ///      xybrid_context_push(ctx, asst_msg);
        ///      xybrid_envelope_free(asst_msg);
        ///  }
        ///
        ///  xybrid_result_free(result);
        ///  xybrid_envelope_free(user_msg);
        ///  xybrid_context_free(ctx);
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_model_run_with_context", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern XybridResultHandle* xybrid_model_run_with_context(XybridModelHandle* model, XybridEnvelopeHandle* envelope, XybridContextHandle* context);

        /// <summary>
        ///  Get the model ID of a loaded model.
        ///
        ///  Returns a pointer to a null-terminated string containing the model ID.
        ///  The caller is responsible for freeing the returned string using
        ///  `xybrid_free_string()`.
        ///
        ///  # Parameters
        ///
        ///  - `model`: A handle to the loaded model.
        ///
        ///  # Returns
        ///
        ///  A pointer to a null-terminated string containing the model ID,
        ///  or null on failure. The caller must free this string with `xybrid_free_string()`.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  char* model_id = xybrid_model_id(model);
        ///  if (model_id != NULL) {
        ///      printf("Model ID: %s\n", model_id);
        ///      xybrid_free_string(model_id);
        ///  }
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_model_id", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* xybrid_model_id(XybridModelHandle* model);

        /// <summary>
        ///  Check if a model supports token-by-token streaming.
        ///
        ///  Returns 1 if the model supports true token-by-token streaming (LLM models
        ///  with GGUF format when LLM features are enabled), 0 otherwise.
        ///
        ///  Note: `xybrid_model_run_streaming()` works for all models, but only LLM
        ///  models get true token-by-token streaming; others emit a single result.
        ///
        ///  # Parameters
        ///
        ///  - `model`: A handle to the loaded model.
        ///
        ///  # Returns
        ///
        ///  - `1` if the model supports token streaming
        ///  - `0` if it does not, or if the handle is null/invalid
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  if (xybrid_model_supports_token_streaming(model)) {
        ///      // Use streaming inference
        ///  } else {
        ///      // Use batch inference
        ///  }
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_model_supports_token_streaming", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int xybrid_model_supports_token_streaming(XybridModelHandle* model);

        /// <summary>
        ///  Run streaming inference on a model with the given input envelope.
        ///
        ///  This function blocks until inference is complete. For each token generated,
        ///  the callback is invoked with the token data. After all tokens are emitted,
        ///  the function returns a result handle with the final output.
        ///
        ///  For non-LLM models, a single callback invocation occurs with the complete result.
        ///
        ///  # Parameters
        ///
        ///  - `model`: A handle to the loaded model.
        ///  - `envelope`: A handle to the input envelope.
        ///  - `callback`: Function pointer invoked for each generated token.
        ///  - `user_data`: Opaque pointer passed through to every callback invocation.
        ///
        ///  # Returns
        ///
        ///  A handle to the final result, or null on failure.
        ///  On failure, call `xybrid_last_error()` to get the error message.
        ///
        ///  # Thread Safety
        ///
        ///  The callback is invoked from the calling thread. The caller must ensure
        ///  that `user_data` is valid for the duration of the call.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  void on_token(const char* token, int64_t token_id, uint32_t index,
        ///                const char* cumulative, const char* finish, void* ctx) {
        ///      printf("%s", token);
        ///      fflush(stdout);
        ///  }
        ///
        ///  XybridResultHandle* result = xybrid_model_run_streaming(
        ///      model, envelope, on_token, NULL);
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_model_run_streaming", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern XybridResultHandle* xybrid_model_run_streaming(XybridModelHandle* model, XybridEnvelopeHandle* envelope, xybrid_model_run_streaming_callback_delegate callback, void* user_data);

        /// <summary>
        ///  Run streaming inference on a model with conversation context.
        ///
        ///  Same as `xybrid_model_run_streaming` but includes conversation history
        ///  for multi-turn LLM interactions.
        ///
        ///  # Parameters
        ///
        ///  - `model`: A handle to the loaded model.
        ///  - `envelope`: A handle to the input envelope (current user message).
        ///  - `context`: A handle to the conversation context.
        ///  - `callback`: Function pointer invoked for each generated token.
        ///  - `user_data`: Opaque pointer passed through to every callback invocation.
        ///
        ///  # Returns
        ///
        ///  A handle to the final result, or null on failure.
        ///  The envelope and context are NOT consumed - they can be reused.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  XybridContextHandle* ctx = xybrid_context_new();
        ///  xybrid_context_set_system(ctx, "You are a helpful assistant.");
        ///
        ///  XybridEnvelopeHandle* msg = xybrid_envelope_text_with_role("Hello!", XYBRID_ROLE_USER);
        ///  xybrid_context_push(ctx, msg);
        ///
        ///  XybridResultHandle* result = xybrid_model_run_streaming_with_context(
        ///      model, msg, ctx, on_token, NULL);
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_model_run_streaming_with_context", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern XybridResultHandle* xybrid_model_run_streaming_with_context(XybridModelHandle* model, XybridEnvelopeHandle* envelope, XybridContextHandle* context, xybrid_model_run_streaming_with_context_callback_delegate callback, void* user_data);

        /// <summary>
        ///  Free a model handle.
        ///
        ///  This function frees the memory associated with a model handle.
        ///  After calling this function, the handle is no longer valid.
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to the model to free. May be null (no-op).
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  xybrid_model_free(model);
        ///  model = NULL; // Good practice: null out after freeing
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_model_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void xybrid_model_free(XybridModelHandle* handle);

        /// <summary>
        ///  Check if the inference was successful.
        ///
        ///  Returns 1 if the inference succeeded, 0 if it failed.
        ///  If the handle is null or invalid, returns 0.
        ///
        ///  # Parameters
        ///
        ///  - `result`: A handle to the inference result.
        ///
        ///  # Returns
        ///
        ///  - `1` if success is true
        ///  - `0` if success is false, or if the handle is null/invalid
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  if (xybrid_result_success(result)) {
        ///      const char* text = xybrid_result_text(result);
        ///      printf("Result: %s\n", text);
        ///  } else {
        ///      const char* error = xybrid_result_error(result);
        ///      printf("Error: %s\n", error ? error : "unknown");
        ///  }
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_result_success", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int xybrid_result_success(XybridResultHandle* result);

        /// <summary>
        ///  Get the error message from a failed inference.
        ///
        ///  Returns a pointer to a null-terminated string containing the error message,
        ///  or null if there was no error. The returned pointer is valid for the
        ///  lifetime of the result handle - do NOT free it with xybrid_free_string().
        ///
        ///  # Parameters
        ///
        ///  - `result`: A handle to the inference result.
        ///
        ///  # Returns
        ///
        ///  A pointer to the error message string, or null if no error.
        ///  The pointer is valid until the result handle is freed.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  if (!xybrid_result_success(result)) {
        ///      const char* error = xybrid_result_error(result);
        ///      fprintf(stderr, "Inference failed: %s\n", error ? error : "unknown error");
        ///  }
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_result_error", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* xybrid_result_error(XybridResultHandle* result);

        /// <summary>
        ///  Get the text output from an inference result.
        ///
        ///  Returns a pointer to a null-terminated string containing the text output,
        ///  or null if the result does not contain text. The returned pointer is valid
        ///  for the lifetime of the result handle - do NOT free it with xybrid_free_string().
        ///
        ///  # Parameters
        ///
        ///  - `result`: A handle to the inference result.
        ///
        ///  # Returns
        ///
        ///  A pointer to the text output string, or null if no text output.
        ///  The pointer is valid until the result handle is freed.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  XybridResultHandle* result = xybrid_model_run(model, envelope);
        ///  if (xybrid_result_success(result)) {
        ///      const char* text = xybrid_result_text(result);
        ///      if (text != NULL) {
        ///          printf("Transcription: %s\n", text);
        ///      }
        ///  }
        ///  xybrid_result_free(result);
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_result_text", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* xybrid_result_text(XybridResultHandle* result);

        /// <summary>
        ///  Get the latency in milliseconds from an inference result.
        ///
        ///  Returns the inference latency in milliseconds.
        ///  If the handle is null or invalid, returns 0.
        ///
        ///  # Parameters
        ///
        ///  - `result`: A handle to the inference result.
        ///
        ///  # Returns
        ///
        ///  The inference latency in milliseconds, or 0 if the handle is null/invalid.
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  uint32_t latency = xybrid_result_latency_ms(result);
        ///  printf("Inference took %u ms\n", latency);
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_result_latency_ms", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern uint xybrid_result_latency_ms(XybridResultHandle* result);

        /// <summary>
        ///  Free an inference result handle.
        ///
        ///  This function frees the memory associated with an inference result handle.
        ///  After calling this function, the handle is no longer valid.
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to the result to free. May be null (no-op).
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  XybridResultHandle* result = xybrid_model_run(model, envelope);
        ///  // ... use result ...
        ///  xybrid_result_free(result);
        ///  result = NULL; // Good practice: null out after freeing
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_result_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void xybrid_result_free(XybridResultHandle* handle);

        /// <summary>
        ///  Open a .xyb bundle file and return a handle.
        ///
        ///  Loads the bundle into memory (decompresses zstd, parses tar, validates manifest).
        ///  The returned handle can be used with other `xybrid_bundle_*` functions.
        ///
        ///  # Parameters
        ///
        ///  - `path`: Null-terminated UTF-8 path to the .xyb file.
        ///
        ///  # Returns
        ///
        ///  A handle to the opened bundle, or null on error (check `xybrid_last_error()`).
        ///
        ///  # Example (C)
        ///
        ///  ```c
        ///  XybridBundleHandle* bundle = xybrid_bundle_open("/path/to/model.xyb");
        ///  if (!bundle) {
        ///      fprintf(stderr, "Failed: %s\n", xybrid_last_error());
        ///  }
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_bundle_open", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern XybridBundleHandle* xybrid_bundle_open(byte* path);

        /// <summary>
        ///  Get the manifest JSON from an opened bundle.
        ///
        ///  Returns the full manifest as a JSON string. The manifest contains:
        ///  `model_id`, `version`, `target`, `hash`, `files`, `has_metadata`.
        ///
        ///  The returned string must be freed with `xybrid_free_string()`.
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to an opened bundle.
        ///
        ///  # Returns
        ///
        ///  A newly allocated null-terminated JSON string, or null on error.
        ///  The caller must free the returned string with `xybrid_free_string()`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_bundle_manifest_json", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* xybrid_bundle_manifest_json(XybridBundleHandle* handle);

        /// <summary>
        ///  Get the model_metadata.json content from an opened bundle.
        ///
        ///  Returns the content of the `model_metadata.json` file inside the bundle,
        ///  or null if the bundle does not contain one.
        ///
        ///  The returned string must be freed with `xybrid_free_string()`.
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to an opened bundle.
        ///
        ///  # Returns
        ///
        ///  A newly allocated null-terminated JSON string, or null if not present or on error.
        ///  Check `xybrid_last_error()` to distinguish "not present" (no error) from failure.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_bundle_metadata_json", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* xybrid_bundle_metadata_json(XybridBundleHandle* handle);

        /// <summary>
        ///  Extract all files from a bundle to a directory.
        ///
        ///  Creates the output directory if it doesn't exist. Extracts all files
        ///  from the bundle, preserving relative paths.
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to an opened bundle.
        ///  - `output_dir`: Null-terminated UTF-8 path to the output directory.
        ///
        ///  # Returns
        ///
        ///  - `0` on success
        ///  - Non-zero on failure (check `xybrid_last_error()`)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_bundle_extract", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int xybrid_bundle_extract(XybridBundleHandle* handle, byte* output_dir);

        /// <summary>
        ///  Get the model ID from an opened bundle's manifest.
        ///
        ///  The returned pointer uses thread-local storage and is valid until the next
        ///  call to this function on the same thread. Do NOT free it.
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to an opened bundle.
        ///
        ///  # Returns
        ///
        ///  A pointer to the model ID string, or null on error.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_bundle_model_id", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* xybrid_bundle_model_id(XybridBundleHandle* handle);

        /// <summary>
        ///  Get the version from an opened bundle's manifest.
        ///
        ///  The returned pointer uses thread-local storage and is valid until the next
        ///  call to this function on the same thread. Do NOT free it.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_bundle_version", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* xybrid_bundle_version(XybridBundleHandle* handle);

        /// <summary>
        ///  Get the target platform from an opened bundle's manifest.
        ///
        ///  The returned pointer uses thread-local storage and is valid until the next
        ///  call to this function on the same thread. Do NOT free it.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_bundle_target", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* xybrid_bundle_target(XybridBundleHandle* handle);

        /// <summary>
        ///  Get the SHA-256 hash from an opened bundle's manifest.
        ///
        ///  The returned pointer uses thread-local storage and is valid until the next
        ///  call to this function on the same thread. Do NOT free it.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_bundle_hash", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* xybrid_bundle_hash(XybridBundleHandle* handle);

        /// <summary>
        ///  Check if the bundle contains a model_metadata.json file.
        ///
        ///  # Returns
        ///
        ///  - `1` if the bundle has model_metadata.json
        ///  - `0` if not, or if the handle is null/invalid
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_bundle_has_metadata", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int xybrid_bundle_has_metadata(XybridBundleHandle* handle);

        /// <summary>
        ///  Get the number of files in the bundle.
        ///
        ///  # Returns
        ///
        ///  The file count, or 0 if the handle is null/invalid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_bundle_file_count", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern uint xybrid_bundle_file_count(XybridBundleHandle* handle);

        /// <summary>
        ///  Get the filename at a given index in the bundle's file list.
        ///
        ///  The returned pointer uses thread-local storage and is valid until the next
        ///  call to this function on the same thread. Do NOT free it.
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to an opened bundle.
        ///  - `index`: Zero-based index into the file list.
        ///
        ///  # Returns
        ///
        ///  A pointer to the filename string, or null if index is out of bounds.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_bundle_file_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* xybrid_bundle_file_name(XybridBundleHandle* handle, uint index);

        /// <summary>
        ///  Free a bundle handle.
        ///
        ///  After calling this function, the handle is no longer valid.
        ///
        ///  # Parameters
        ///
        ///  - `handle`: A handle to the bundle to free. May be null (no-op).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "xybrid_bundle_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void xybrid_bundle_free(XybridBundleHandle* handle);


    }

    /// <summary>
    ///  Opaque handle to a model loader.
    ///
    ///  This handle is created by `xybrid_model_loader_from_registry` or
    ///  `xybrid_model_loader_from_bundle` and must be freed with
    ///  `xybrid_model_loader_free`.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct XybridModelLoaderHandle
    {
        public void* Item1;
    }

    /// <summary>
    ///  Opaque handle to a loaded model.
    ///
    ///  This handle is created by `xybrid_model_loader_load` and must be
    ///  freed with `xybrid_model_free`.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct XybridModelHandle
    {
        public void* Item1;
    }

    /// <summary>
    ///  Opaque handle to an envelope (input data).
    ///
    ///  This handle is created by `xybrid_envelope_audio` or `xybrid_envelope_text`
    ///  and must be freed with `xybrid_envelope_free`.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct XybridEnvelopeHandle
    {
        public void* Item1;
    }

    /// <summary>
    ///  Opaque handle to an inference result.
    ///
    ///  This handle is created by `xybrid_model_run` and must be freed with
    ///  `xybrid_result_free`.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct XybridResultHandle
    {
        public void* Item1;
    }

    /// <summary>
    ///  Opaque handle to a conversation context.
    ///
    ///  This handle is created by `xybrid_context_new` and must be freed with
    ///  `xybrid_context_free`.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct XybridContextHandle
    {
        public void* Item1;
    }

    /// <summary>
    ///  Opaque handle to a loaded bundle.
    ///
    ///  This handle is created by `xybrid_bundle_open` and must be freed with
    ///  `xybrid_bundle_free`.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct XybridBundleHandle
    {
        public void* Item1;
    }



}
