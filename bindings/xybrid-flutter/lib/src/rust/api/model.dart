// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by flutter_rust_bridge_codegen
// See: https://cjycode.com/flutter_rust_bridge/

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'envelope.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'result.dart';
part 'model.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `from`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FfiModel>>
abstract class FfiModel implements RustOpaqueInterface {
  /// Run batch inference (non-streaming).
  Future<FfiResult> run({required FfiEnvelope envelope});

  /// Run inference with streaming output.
  ///
  /// Returns a stream of events:
  /// - `FfiStreamEvent::Token` for each generated token (LLM models)
  /// - `FfiStreamEvent::Complete` when inference finishes
  /// - `FfiStreamEvent::Error` if an error occurs
  ///
  /// For non-LLM models, a single Token event is emitted with the full result.
  Stream<FfiStreamEvent> runStream({required FfiEnvelope envelope});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FfiModelLoader>>
abstract class FfiModelLoader implements RustOpaqueInterface {
  static FfiModelLoader fromBundle({required String path}) => XybridRustLib
      .instance
      .api
      .crateApiModelFfiModelLoaderFromBundle(path: path);

  static FfiModelLoader fromRegistry({required String modelId}) => XybridRustLib
      .instance
      .api
      .crateApiModelFfiModelLoaderFromRegistry(modelId: modelId);

  /// Load the model without progress updates.
  Future<FfiModel> load();

  /// Load the model with download progress updates.
  ///
  /// Streams FfiLoadEvent during download:
  /// - `Progress(f64)` for download progress (0.0 to 1.0)
  /// - `Complete` when the model is ready
  /// - `Error(String)` if loading fails
  ///
  /// After receiving `Complete`, call `load()` to get the cached model instantly.
  Stream<FfiLoadEvent> loadWithProgress();
}

@freezed
sealed class FfiLoadEvent with _$FfiLoadEvent {
  const FfiLoadEvent._();

  /// Download progress update (0.0 to 1.0)
  const factory FfiLoadEvent.progress(double field0) = FfiLoadEvent_Progress;

  /// Model loaded successfully - contains the model handle ID
  const factory FfiLoadEvent.complete() = FfiLoadEvent_Complete;

  /// An error occurred during loading
  const factory FfiLoadEvent.error(String field0) = FfiLoadEvent_Error;
}

@freezed
sealed class FfiStreamEvent with _$FfiStreamEvent {
  const FfiStreamEvent._();

  /// A token was generated
  const factory FfiStreamEvent.token(FfiStreamToken field0) =
      FfiStreamEvent_Token;

  /// Inference completed with final result
  const factory FfiStreamEvent.complete(FfiResult field0) =
      FfiStreamEvent_Complete;

  /// An error occurred
  const factory FfiStreamEvent.error(String field0) = FfiStreamEvent_Error;
}

/// Token received during streaming inference.
/// Mirrors the SDK's StreamToken structure for FFI.
class FfiStreamToken {
  /// The generated token text
  final String token;

  /// The token ID (if available)
  final PlatformInt64? tokenId;

  /// Index of this token in the sequence
  final int index;

  /// Cumulative text generated so far
  final String cumulativeText;

  /// Reason for stopping (if this is the final token)
  final String? finishReason;

  const FfiStreamToken({
    required this.token,
    this.tokenId,
    required this.index,
    required this.cumulativeText,
    this.finishReason,
  });

  @override
  int get hashCode =>
      token.hashCode ^
      tokenId.hashCode ^
      index.hashCode ^
      cumulativeText.hashCode ^
      finishReason.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiStreamToken &&
          runtimeType == other.runtimeType &&
          token == other.token &&
          tokenId == other.tokenId &&
          index == other.index &&
          cumulativeText == other.cumulativeText &&
          finishReason == other.finishReason;
}
